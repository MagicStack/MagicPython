%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: MagicPython
file_extensions:
  - py
  - py3
  - rpy
  - pyw
  - cpy
  - pyi
  - SConstruct
  - Sconstruct
  - sconstruct
  - SConscript
  - gyp
  - gypi
  - wsgi
  - kv
  - Snakefile
  - tac
first_line_match: '^#![ \t]*/.*\bpython[\d\.]*\b'
scope: source.python
contexts:
  main:
    - include: statement
    - include: expression
  annotated-parameter:
    - match: |-
        (?x)
        \b
        ([[:alpha:]_]\w*) \s* (:)
      captures:
        1: variable.parameter.function.language.python
        2: punctuation.separator.annotation.python
      push:
        - match: (,)|(?=\))
          captures:
            1: punctuation.separator.parameters.python
          pop: true
        - include: expression
        - match: "=(?!=)"
          scope: keyword.operator.assignment.python
  assignment-operator:
    - match: |-
        (?x)
         <<= | >>= | //= | \*\*=
        | \+= | -= | /= | @=
        | \*= | %= | ~= | \^= | &= | \|=
        | =(?!=)
      scope: keyword.operator.assignment.python
  backticks:
    - match: \`
      push:
        - meta_scope: invalid.deprecated.backtick.python
        - match: (?:\`|(?<!\\)(\n))
          pop: true
        - include: expression
  builtin-callables:
    - include: illegal-names
    - include: illegal-object-name
    - include: builtin-exceptions
    - include: builtin-functions
    - include: builtin-types
  builtin-exceptions:
    - match: |-
        (?x) (?<!\.) \b(
          (
            Arithmetic | Assertion | Attribute | Buffer | BlockingIO
            | BrokenPipe | ChildProcess
            | (Connection (Aborted | Refused | Reset)?)
            | EOF | Environment | FileExists | FileNotFound
            | FloatingPoint | IO | Import | Indentation | Index | Interrupted
            | IsADirectory | NotADirectory | Permission | ProcessLookup
            | Timeout
            | Key | Lookup | Memory | Name | NotImplemented | OS | Overflow
            | Reference | Runtime | Recursion | Syntax | System
            | Tab | Type | UnboundLocal | Unicode(Encode|Decode|Translate)?
            | Value | Windows | ZeroDivision | ModuleNotFound
          ) Error
        |
          ((Pending)?Deprecation | Runtime | Syntax | User | Future | Import
            | Unicode | Bytes | Resource
          )? Warning
        |
          SystemExit | Stop(Async)?Iteration
          | KeyboardInterrupt
          | GeneratorExit | (Base)?Exception
        )\b
      scope: support.type.exception.python
  builtin-functions:
    - match: |-
        (?x)
        (?<!\.) \b(
          __import__ | abs | all | any | ascii | bin | callable
          | chr | compile | copyright | credits | delattr | dir | divmod
          | enumerate | eval | exec | exit | filter | format | getattr
          | globals | hasattr | hash | help | hex | id | input
          | isinstance | issubclass | iter | len | license | locals | map
          | max | memoryview | min | next | oct | open | ord | pow | print
          | quit | range | reload | repr | reversed | round
          | setattr | sorted | sum | vars | zip
        )\b
      scope: support.function.builtin.python
    - match: |-
        (?x)
        (?<!\.) \b(
          file | reduce | intern | raw_input | unicode | cmp | basestring
          | execfile | long | xrange
        )\b
      scope: variable.legacy.builtin.python
  builtin-possible-callables:
    - include: builtin-callables
    - include: magic-names
  builtin-types:
    - match: |-
        (?x)
          (?<!\.) \b(
            bool | bytearray | bytes | classmethod | complex | dict
            | float | frozenset | int | list | object | property
            | set | slice | staticmethod | str | tuple | type

            (?# Although 'super' is not a type, it's related to types,
                and is special enough to be highlighted differently from
                other built-ins)
            | super
          )\b
      scope: support.type.python
  call-wrapper-inheritance:
    - match: |-
        (?x)
        \b(?=
          ([[:alpha:]_]\w*) \s* (\()
        )
      comment: same as a function call, but in inheritance context
      push:
        - meta_scope: meta.function-call.python
        - match: (\))
          captures:
            1: punctuation.definition.arguments.end.python
          pop: true
        - include: inheritance-name
        - include: function-arguments
  class-declaration:
    - match: |-
        (?x)
        \s*(class)\s+
          (?=
            [[:alpha:]_]\w* \s* (:|\()
          )
      captures:
        1: storage.type.class.python
      push:
        - meta_scope: meta.class.python
        - match: (:)
          captures:
            1: punctuation.section.class.begin.python
          pop: true
        - include: class-name
        - include: class-inheritance
  class-inheritance:
    - match: (\()
      captures:
        1: punctuation.definition.inheritance.begin.python
      push:
        - meta_scope: meta.class.inheritance.python
        - match: (\))
          captures:
            1: punctuation.definition.inheritance.end.python
          pop: true
        - match: (\*\*|\*)
          scope: keyword.operator.unpacking.arguments.python
        - match: ","
          scope: punctuation.separator.inheritance.python
        - match: "=(?!=)"
          scope: keyword.operator.assignment.python
        - match: \bmetaclass\b
          scope: support.type.metaclass.python
        - include: illegal-names
        - include: class-kwarg
        - include: call-wrapper-inheritance
        - include: expression-base
        - include: member-access-class
        - include: inheritance-identifier
  class-kwarg:
    - match: |-
        (?x)
        \b ([[:alpha:]_]\w*) \s*(=)(?!=)
      captures:
        1: entity.other.inherited-class.python variable.parameter.class.python
        2: keyword.operator.assignment.python
  class-name:
    - include: illegal-object-name
    - include: builtin-possible-callables
    - match: |-
        (?x)
        \b ([[:alpha:]_]\w*) \b
      scope: entity.name.type.class.python
  codetags:
    - match: (?:\b(NOTE|XXX|HACK|FIXME|BUG|TODO)\b)
      captures:
        1: keyword.codetag.notation.python
  comments:
    - match: |-
        (?x)
        (?:
          \# \s* (type:)
          \s*+ (?# we want `\s*+` which is possessive quantifier since
                   we do not actually want to backtrack when matching
                   whitespace here)
          (?! $ | \#)
        )
      captures:
        0: meta.typehint.comment.python
        1: comment.typehint.directive.notation.python
      push:
        - meta_scope: comment.line.number-sign.python
        - meta_content_scope: meta.typehint.comment.python
        - match: (?:$|(?=\#))
          pop: true
        - match: |-
            (?x)
            \G ignore
            (?= \s* (?: $ | \#))
          scope: comment.typehint.ignore.notation.python
        - match: |-
            (?x)
            (?<!\.)\b(
              bool | bytes | float | int | object | str
              | List | Dict | Iterable | Sequence | Set
              | FrozenSet | Callable | Union | Tuple
              | Any | None
            )\b
          scope: comment.typehint.type.notation.python
        - match: '([\[\]\(\),\.\=\*]|(->))'
          scope: comment.typehint.punctuation.notation.python
        - match: '([[:alpha:]_]\w*)'
          scope: comment.typehint.variable.notation.python
    - include: comments-base
  comments-base:
    - match: (\#)
      captures:
        1: punctuation.definition.comment.python
      push:
        - meta_scope: comment.line.number-sign.python
        - match: ($)
          pop: true
        - include: codetags
  comments-string-double-three:
    - match: (\#)
      captures:
        1: punctuation.definition.comment.python
      push:
        - meta_scope: comment.line.number-sign.python
        - match: ($|(?="""))
          pop: true
        - include: codetags
  comments-string-single-three:
    - match: (\#)
      captures:
        1: punctuation.definition.comment.python
      push:
        - meta_scope: comment.line.number-sign.python
        - match: ($|(?='''))
          pop: true
        - include: codetags
  curly-braces:
    - match: '\{'
      captures:
        0: punctuation.definition.dict.begin.python
      push:
        - match: '\}'
          captures:
            0: punctuation.definition.dict.end.python
          pop: true
        - match: ":"
          scope: punctuation.separator.dict.python
        - include: expression
  decorator:
    - match: |-
        (?x)
        ^\s*
        (@) \s* (?=[[:alpha:]_]\w*)
      captures:
        1: entity.name.function.decorator.python
      push:
        - meta_scope: meta.function.decorator.python
        - match: |-
            (?x)
            ( \) )
              # trailing whitespace and comments are legal
              (?: (.*?) (?=\s*(?:\#|$)) )
            | (?=\n|\#)
          captures:
            1: punctuation.definition.arguments.end.python
            2: invalid.illegal.decorator.python
          pop: true
        - include: decorator-name
        - include: function-arguments
  decorator-name:
    - include: builtin-callables
    - include: illegal-object-name
    - match: |-
        (?x)
        ([[:alpha:]_]\w*) | \.
      scope: entity.name.function.decorator.python
    - include: line-continuation
    - match: |-
        (?x)
        \s* ([^([:alpha:]\s_\.#\\] .*?) (?=\#|$)
      scope: invalid.illegal.decorator.python
      captures:
        1: invalid.illegal.decorator.python
  docstring:
    - match: (\'\'\'|\"\"\")
      captures:
        1: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.docstring.multi.python
        - match: (\1)
          captures:
            1: punctuation.definition.string.end.python
          pop: true
        - include: docstring-prompt
        - include: codetags
        - include: docstring-guts-unicode
    - match: '([rR])(\''\''\''|\"\"\")'
      captures:
        1: storage.type.string.python
        2: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.docstring.raw.multi.python
        - match: (\2)
          captures:
            1: punctuation.definition.string.end.python
          pop: true
        - include: string-consume-escape
        - include: docstring-prompt
        - include: codetags
    - match: (\'|\")
      captures:
        1: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.docstring.single.python
        - match: (\1)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: codetags
        - include: docstring-guts-unicode
    - match: '([rR])(\''|\")'
      captures:
        1: storage.type.string.python
        2: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.docstring.raw.single.python
        - match: (\2)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-consume-escape
        - include: codetags
  docstring-guts-unicode:
    - include: escape-sequence-unicode
    - include: escape-sequence
    - include: string-line-continuation
  docstring-prompt:
    - match: |-
        (?x)
        (?:
          (?:^|\G) \s* (?# '\G' is necessary for ST)
          ((?:>>>|\.\.\.) \s) (?=\s*\S)
        )
      captures:
        1: keyword.control.flow.python
  docstring-statement:
    - match: '^(?=\s*[rR]?(\''\''\''|\"\"\"|\''|\"))'
      push:
        - match: (?<=\'\'\'|\"\"\"|\'|\")
          pop: true
        - include: docstring
  double-one-fregexp-conditional:
    - match: '(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)'
      captures:
        0: keyword.operator.conditional.regexp
        1: punctuation.parenthesis.conditional.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  double-one-fregexp-expression:
    - include: fregexp-base-expression
    - include: double-one-regexp-character-set
    - include: double-one-regexp-comments
    - include: regexp-flags
    - include: double-one-regexp-named-group
    - include: regexp-backreference
    - include: double-one-fregexp-lookahead
    - include: double-one-fregexp-lookahead-negative
    - include: double-one-fregexp-lookbehind
    - include: double-one-fregexp-lookbehind-negative
    - include: double-one-fregexp-conditional
    - include: double-one-fregexp-parentheses-non-capturing
    - include: double-one-fregexp-parentheses
  double-one-fregexp-lookahead:
    - match: (\()\?=
      captures:
        0: keyword.operator.lookahead.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  double-one-fregexp-lookahead-negative:
    - match: (\()\?!
      captures:
        0: keyword.operator.lookahead.negative.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  double-one-fregexp-lookbehind:
    - match: (\()\?<=
      captures:
        0: keyword.operator.lookbehind.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  double-one-fregexp-lookbehind-negative:
    - match: (\()\?<!
      captures:
        0: keyword.operator.lookbehind.negative.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  double-one-fregexp-named-group:
    - match: |-
        (?x)
        (\()  (\?P <\w+(?:\s+[[:alnum:]]+)?>)
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp
        2: entity.name.tag.named.group.regexp
      push:
        - meta_scope: meta.named.regexp
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  double-one-fregexp-parentheses:
    - match: \(
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  double-one-fregexp-parentheses-non-capturing:
    - match: '\(\?:'
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  double-one-regexp-character-set:
    - match: |-
        (?x)
        \[ \^? \] (?! .*?\])
    - match: '(\[)(\^)?(\])?'
      captures:
        1: punctuation.character.set.begin.regexp constant.other.set.regexp
        2: keyword.operator.negation.regexp
        3: constant.character.set.regexp
      push:
        - meta_scope: meta.character.set.regexp
        - match: '(\]|(?="))|((?=(?<!\\)\n))'
          captures:
            1: punctuation.character.set.end.regexp constant.other.set.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: regexp-charecter-set-escapes
        - match: '[^\n]'
          scope: constant.character.set.regexp
  double-one-regexp-comments:
    - match: '\(\?#'
      captures:
        0: punctuation.comment.begin.regexp
      push:
        - meta_scope: comment.regexp
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: punctuation.comment.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: codetags
  double-one-regexp-conditional:
    - match: '(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)'
      captures:
        0: keyword.operator.conditional.regexp
        1: punctuation.parenthesis.conditional.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  double-one-regexp-expression:
    - include: regexp-base-expression
    - include: double-one-regexp-character-set
    - include: double-one-regexp-comments
    - include: regexp-flags
    - include: double-one-regexp-named-group
    - include: regexp-backreference
    - include: double-one-regexp-lookahead
    - include: double-one-regexp-lookahead-negative
    - include: double-one-regexp-lookbehind
    - include: double-one-regexp-lookbehind-negative
    - include: double-one-regexp-conditional
    - include: double-one-regexp-parentheses-non-capturing
    - include: double-one-regexp-parentheses
  double-one-regexp-lookahead:
    - match: (\()\?=
      captures:
        0: keyword.operator.lookahead.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  double-one-regexp-lookahead-negative:
    - match: (\()\?!
      captures:
        0: keyword.operator.lookahead.negative.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  double-one-regexp-lookbehind:
    - match: (\()\?<=
      captures:
        0: keyword.operator.lookbehind.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  double-one-regexp-lookbehind-negative:
    - match: (\()\?<!
      captures:
        0: keyword.operator.lookbehind.negative.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  double-one-regexp-named-group:
    - match: |-
        (?x)
        (\()  (\?P <\w+(?:\s+[[:alnum:]]+)?>)
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp
        2: entity.name.tag.named.group.regexp
      push:
        - meta_scope: meta.named.regexp
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  double-one-regexp-parentheses:
    - match: \(
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  double-one-regexp-parentheses-non-capturing:
    - match: '\(\?:'
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp
      push:
        - match: (\)|(?="))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  double-three-fregexp-conditional:
    - match: '(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)'
      captures:
        0: keyword.operator.conditional.regexp
        1: punctuation.parenthesis.conditional.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
        - include: comments-string-double-three
  double-three-fregexp-expression:
    - include: fregexp-base-expression
    - include: double-three-regexp-character-set
    - include: double-three-regexp-comments
    - include: regexp-flags
    - include: double-three-regexp-named-group
    - include: regexp-backreference
    - include: double-three-fregexp-lookahead
    - include: double-three-fregexp-lookahead-negative
    - include: double-three-fregexp-lookbehind
    - include: double-three-fregexp-lookbehind-negative
    - include: double-three-fregexp-conditional
    - include: double-three-fregexp-parentheses-non-capturing
    - include: double-three-fregexp-parentheses
    - include: comments-string-double-three
  double-three-fregexp-lookahead:
    - match: (\()\?=
      captures:
        0: keyword.operator.lookahead.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
        - include: comments-string-double-three
  double-three-fregexp-lookahead-negative:
    - match: (\()\?!
      captures:
        0: keyword.operator.lookahead.negative.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
        - include: comments-string-double-three
  double-three-fregexp-lookbehind:
    - match: (\()\?<=
      captures:
        0: keyword.operator.lookbehind.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
        - include: comments-string-double-three
  double-three-fregexp-lookbehind-negative:
    - match: (\()\?<!
      captures:
        0: keyword.operator.lookbehind.negative.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
        - include: comments-string-double-three
  double-three-fregexp-named-group:
    - match: |-
        (?x)
        (\()  (\?P <\w+(?:\s+[[:alnum:]]+)?>)
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp
        2: entity.name.tag.named.group.regexp
      push:
        - meta_scope: meta.named.regexp
        - match: (\)|(?="""))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
        - include: comments-string-double-three
  double-three-fregexp-parentheses:
    - match: \(
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
        - include: comments-string-double-three
  double-three-fregexp-parentheses-non-capturing:
    - match: '\(\?:'
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
        - include: comments-string-double-three
  double-three-regexp-character-set:
    - match: |-
        (?x)
        \[ \^? \] (?! .*?\])
    - match: '(\[)(\^)?(\])?'
      captures:
        1: punctuation.character.set.begin.regexp constant.other.set.regexp
        2: keyword.operator.negation.regexp
        3: constant.character.set.regexp
      push:
        - meta_scope: meta.character.set.regexp
        - match: '(\]|(?="""))'
          captures:
            1: punctuation.character.set.end.regexp constant.other.set.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: regexp-charecter-set-escapes
        - match: '[^\n]'
          scope: constant.character.set.regexp
  double-three-regexp-comments:
    - match: '\(\?#'
      captures:
        0: punctuation.comment.begin.regexp
      push:
        - meta_scope: comment.regexp
        - match: (\)|(?="""))
          captures:
            1: punctuation.comment.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: codetags
  double-three-regexp-conditional:
    - match: '(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)'
      captures:
        0: keyword.operator.conditional.regexp
        1: punctuation.parenthesis.conditional.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
        - include: comments-string-double-three
  double-three-regexp-expression:
    - include: regexp-base-expression
    - include: double-three-regexp-character-set
    - include: double-three-regexp-comments
    - include: regexp-flags
    - include: double-three-regexp-named-group
    - include: regexp-backreference
    - include: double-three-regexp-lookahead
    - include: double-three-regexp-lookahead-negative
    - include: double-three-regexp-lookbehind
    - include: double-three-regexp-lookbehind-negative
    - include: double-three-regexp-conditional
    - include: double-three-regexp-parentheses-non-capturing
    - include: double-three-regexp-parentheses
    - include: comments-string-double-three
  double-three-regexp-lookahead:
    - match: (\()\?=
      captures:
        0: keyword.operator.lookahead.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
        - include: comments-string-double-three
  double-three-regexp-lookahead-negative:
    - match: (\()\?!
      captures:
        0: keyword.operator.lookahead.negative.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
        - include: comments-string-double-three
  double-three-regexp-lookbehind:
    - match: (\()\?<=
      captures:
        0: keyword.operator.lookbehind.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
        - include: comments-string-double-three
  double-three-regexp-lookbehind-negative:
    - match: (\()\?<!
      captures:
        0: keyword.operator.lookbehind.negative.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
        - include: comments-string-double-three
  double-three-regexp-named-group:
    - match: |-
        (?x)
        (\()  (\?P <\w+(?:\s+[[:alnum:]]+)?>)
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp
        2: entity.name.tag.named.group.regexp
      push:
        - meta_scope: meta.named.regexp
        - match: (\)|(?="""))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
        - include: comments-string-double-three
  double-three-regexp-parentheses:
    - match: \(
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
        - include: comments-string-double-three
  double-three-regexp-parentheses-non-capturing:
    - match: '\(\?:'
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp
      push:
        - match: (\)|(?="""))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
        - include: comments-string-double-three
  ellipsis:
    - match: \.\.\.
      scope: constant.other.ellipsis.python
  escape-sequence:
    - match: |-
        (?x)
        \\ (
              x[0-9A-Fa-f]{2}
              | [0-7]{1,3}
              | [\\"'abfnrtv]
           )
      scope: constant.character.escape.python
  escape-sequence-unicode:
    - match: |-
        (?x)
        \\ (
              u[0-9A-Fa-f]{4}
              | U[0-9A-Fa-f]{8}
              | N\{[\w\s]+?\}
           )
      scope: constant.character.escape.python
  expression:
    - include: expression-base
    - include: member-access
    - match: '(?x) \b ([[:alpha:]_]\w*) \b'
      comment: Tokenize identifiers to help linters
  expression-bare:
    - include: backticks
    - include: illegal-anno
    - include: literal
    - include: regexp
    - include: string
    - include: lambda
    - include: illegal-operator
    - include: operator
    - include: curly-braces
    - include: item-access
    - include: list
    - include: round-braces
    - include: function-call
    - include: builtin-functions
    - include: builtin-types
    - include: builtin-exceptions
    - include: magic-names
    - include: special-names
    - include: illegal-names
    - include: special-variables
    - include: ellipsis
    - include: punctuation
    - include: line-continuation
  expression-base:
    - include: comments
    - include: expression-bare
    - include: line-continuation
  f-expression:
    - include: expression-bare
    - include: member-access
    - match: '(?x) \b ([[:alpha:]_]\w*) \b'
      comment: Tokenize identifiers to help linters
  fregexp-base-expression:
    - include: fregexp-quantifier
    - include: fstring-formatting-braces
    - match: '\{.*?\}'
    - include: regexp-base-common
  fregexp-double-one-line:
    - match: '\b(([uU]r)|([fF]r)|(r[fF]?))(")'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: storage.type.string.python
        5: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.interpolated.python string.regexp.quoted.single.python
        - match: (")|(?<!\\)(\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-fregexp-expression
  fregexp-double-three-line:
    - match: '\b(([uU]r)|([fF]r)|(r[fF]?))(""")'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: storage.type.string.python
        5: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.interpolated.python string.regexp.quoted.multi.python
        - match: (""")
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-fregexp-expression
  fregexp-quantifier:
    - match: |-
        (?x)
        \{\{(
          \d+ | \d+,(\d+)? | ,\d+
        )\}\}
      scope: keyword.operator.quantifier.regexp
  fregexp-single-one-line:
    - match: '\b(([uU]r)|([fF]r)|(r[fF]?))(\'')'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: storage.type.string.python
        5: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.interpolated.python string.regexp.quoted.single.python
        - match: (\')|(?<!\\)(\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  fregexp-single-three-line:
    - match: '\b(([uU]r)|([fF]r)|(r[fF]?))(\''\''\'')'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: storage.type.string.python
        5: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.interpolated.python string.regexp.quoted.multi.python
        - match: (\'\'\')
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
  fstring-fnorm-quoted-multi-line:
    - match: '(\b[fF])([bBuU])?(''''''|""")'
      captures:
        1: string.interpolated.python string.quoted.multi.python storage.type.string.python
        2: invalid.illegal.prefix.python
        3: punctuation.definition.string.begin.python string.interpolated.python string.quoted.multi.python
      push:
        - meta_scope: meta.fstring.python
        - match: (\3)
          captures:
            1: punctuation.definition.string.end.python string.interpolated.python string.quoted.multi.python
            2: invalid.illegal.newline.python
          pop: true
        - include: fstring-guts
        - include: fstring-illegal-multi-brace
        - include: fstring-multi-brace
        - include: fstring-multi-core
  fstring-fnorm-quoted-single-line:
    - match: '(\b[fF])([bBuU])?(([''"]))'
      captures:
        1: string.interpolated.python string.quoted.single.python storage.type.string.python
        2: invalid.illegal.prefix.python
        3: punctuation.definition.string.begin.python string.interpolated.python string.quoted.single.python
      push:
        - meta_scope: meta.fstring.python
        - match: (\3)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python string.interpolated.python string.quoted.single.python
            2: invalid.illegal.newline.python
          pop: true
        - include: fstring-guts
        - include: fstring-illegal-single-brace
        - include: fstring-single-brace
        - include: fstring-single-core
  fstring-formatting:
    - include: fstring-formatting-braces
    - include: fstring-formatting-singe-brace
  fstring-formatting-braces:
    - match: '({)(\s*?)(})'
      comment: empty braces are illegal
      captures:
        1: constant.character.format.placeholder.other.python
        2: invalid.illegal.brace.python
        3: constant.character.format.placeholder.other.python
    - match: "({{|}})"
      scope: constant.character.escape.python
  fstring-formatting-singe-brace:
    - match: "(}(?!}))"
      scope: invalid.illegal.brace.python
  fstring-guts:
    - include: escape-sequence-unicode
    - include: escape-sequence
    - include: string-line-continuation
    - include: fstring-formatting
  fstring-illegal-multi-brace:
    - include: impossible
  fstring-illegal-single-brace:
    - match: '(\{)(?=[^\n}]*$\n?)'
      comment: it is illegal to have a multiline brace inside a single-line string
      captures:
        1: constant.character.format.placeholder.other.python
      push:
        - match: '(\})|(?=\n)'
          captures:
            1: constant.character.format.placeholder.other.python
          pop: true
        - include: fstring-terminator-single
        - include: f-expression
  fstring-multi-brace:
    - match: '(\{)'
      comment: "value interpolation using { ... }"
      captures:
        1: constant.character.format.placeholder.other.python
      push:
        - match: |-
            (?x)
            (\})
          captures:
            1: constant.character.format.placeholder.other.python
          pop: true
        - include: fstring-terminator-multi
        - include: f-expression
  fstring-multi-core:
    - match: |-
        (?x)
          (.+?)
            (
              (?# .* and .*? in multi-line match need special handling of
                newlines otherwise SublimeText and Atom will match slightly
                differently.

                The guard for newlines has to be separate from the
                lookahead because of special $ matching rule.)
              ($\n?)
              |
              (?=[\\\}\{]|'''|""")
            )
          (?# due to how multiline regexps are matched we need a special case
            for matching a newline character)
          | \n
      scope: string.interpolated.python string.quoted.multi.python
  fstring-normf-quoted-multi-line:
    - match: '(\b[bBuU])([fF])(''''''|""")'
      captures:
        1: invalid.illegal.prefix.python
        2: string.interpolated.python string.quoted.multi.python storage.type.string.python
        3: punctuation.definition.string.begin.python string.quoted.multi.python
      push:
        - meta_scope: meta.fstring.python
        - match: (\3)
          captures:
            1: punctuation.definition.string.end.python string.interpolated.python string.quoted.multi.python
            2: invalid.illegal.newline.python
          pop: true
        - include: fstring-guts
        - include: fstring-illegal-multi-brace
        - include: fstring-multi-brace
        - include: fstring-multi-core
  fstring-normf-quoted-single-line:
    - match: '(\b[bBuU])([fF])(([''"]))'
      captures:
        1: invalid.illegal.prefix.python
        2: string.interpolated.python string.quoted.single.python storage.type.string.python
        3: punctuation.definition.string.begin.python string.quoted.single.python
      push:
        - meta_scope: meta.fstring.python
        - match: (\3)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python string.interpolated.python string.quoted.single.python
            2: invalid.illegal.newline.python
          pop: true
        - include: fstring-guts
        - include: fstring-illegal-single-brace
        - include: fstring-single-brace
        - include: fstring-single-core
  fstring-raw-guts:
    - include: string-consume-escape
    - include: fstring-formatting
  fstring-raw-multi-core:
    - match: |-
        (?x)
          (.+?)
            (
              (?# .* and .*? in multi-line match need special handling of
                newlines otherwise SublimeText and Atom will match slightly
                differently.

                The guard for newlines has to be separate from the
                lookahead because of special $ matching rule.)
              ($\n?)
              |
              (?=[\\\}\{]|'''|""")
            )
          (?# due to how multiline regexps are matched we need a special case
            for matching a newline character)
          | \n
      scope: string.interpolated.python string.quoted.raw.multi.python
  fstring-raw-quoted-multi-line:
    - match: '(\b(?:[R][fF]|[fF][R]))(''''''|""")'
      captures:
        1: string.interpolated.python string.quoted.raw.multi.python storage.type.string.python
        2: punctuation.definition.string.begin.python string.quoted.raw.multi.python
      push:
        - meta_scope: meta.fstring.python
        - match: (\2)
          captures:
            1: punctuation.definition.string.end.python string.interpolated.python string.quoted.raw.multi.python
            2: invalid.illegal.newline.python
          pop: true
        - include: fstring-raw-guts
        - include: fstring-illegal-multi-brace
        - include: fstring-multi-brace
        - include: fstring-raw-multi-core
  fstring-raw-quoted-single-line:
    - match: '(\b(?:[R][fF]|[fF][R]))(([''"]))'
      captures:
        1: string.interpolated.python string.quoted.raw.single.python storage.type.string.python
        2: punctuation.definition.string.begin.python string.quoted.raw.single.python
      push:
        - meta_scope: meta.fstring.python
        - match: (\2)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python string.interpolated.python string.quoted.raw.single.python
            2: invalid.illegal.newline.python
          pop: true
        - include: fstring-raw-guts
        - include: fstring-illegal-single-brace
        - include: fstring-single-brace
        - include: fstring-raw-single-core
  fstring-raw-single-core:
    - match: |-
        (?x)
          (.+?)
            (
              (?# .* and .*? in multi-line match need special handling of
                newlines otherwise SublimeText and Atom will match slightly
                differently.

                The guard for newlines has to be separate from the
                lookahead because of special $ matching rule.)
              ($\n?)
              |
              (?=[\\\}\{]|(['"])|((?<!\\)\n))
            )
          (?# due to how multiline regexps are matched we need a special case
            for matching a newline character)
          | \n
      scope: string.interpolated.python string.quoted.raw.single.python
  fstring-single-brace:
    - match: '(\{)'
      comment: "value interpolation using { ... }"
      captures:
        1: constant.character.format.placeholder.other.python
      push:
        - match: |-
            (?x)
            (\})|(?=\n)
          captures:
            1: constant.character.format.placeholder.other.python
          pop: true
        - include: fstring-terminator-single
        - include: f-expression
  fstring-single-core:
    - match: |-
        (?x)
          (.+?)
            (
              (?# .* and .*? in multi-line match need special handling of
                newlines otherwise SublimeText and Atom will match slightly
                differently.

                The guard for newlines has to be separate from the
                lookahead because of special $ matching rule.)
              ($\n?)
              |
              (?=[\\\}\{]|(['"])|((?<!\\)\n))
            )
          (?# due to how multiline regexps are matched we need a special case
            for matching a newline character)
          | \n
      scope: string.interpolated.python string.quoted.single.python
  fstring-terminator-multi:
    - match: "(![rsa])(?=})"
      scope: storage.type.format.python
    - match: |-
        (?x)
        (![rsa])?
          ( : \w? [<>=^]? [-+ ]? \#?
            \d* ,? (\.\d+)? [bcdeEfFgGnosxX%]? )(?=})
      captures:
        1: storage.type.format.python
        2: storage.type.format.python
    - include: fstring-terminator-multi-tail
  fstring-terminator-multi-tail:
    - match: "(![rsa])?(:)(?=.*?{)"
      captures:
        1: storage.type.format.python
        2: storage.type.format.python
      push:
        - match: "(?=})"
          pop: true
        - include: fstring-illegal-multi-brace
        - include: fstring-multi-brace
        - match: "([bcdeEfFgGnosxX%])(?=})"
          scope: storage.type.format.python
        - match: (\.\d+)
          scope: storage.type.format.python
        - match: (,)
          scope: storage.type.format.python
        - match: (\d+)
          scope: storage.type.format.python
        - match: (\#)
          scope: storage.type.format.python
        - match: "([-+ ])"
          scope: storage.type.format.python
        - match: "([<>=^])"
          scope: storage.type.format.python
        - match: (\w)
          scope: storage.type.format.python
  fstring-terminator-single:
    - match: "(![rsa])(?=})"
      scope: storage.type.format.python
    - match: |-
        (?x)
        (![rsa])?
          ( : \w? [<>=^]? [-+ ]? \#?
            \d* ,? (\.\d+)? [bcdeEfFgGnosxX%]? )(?=})
      captures:
        1: storage.type.format.python
        2: storage.type.format.python
    - include: fstring-terminator-single-tail
  fstring-terminator-single-tail:
    - match: "(![rsa])?(:)(?=.*?{)"
      captures:
        1: storage.type.format.python
        2: storage.type.format.python
      push:
        - match: '(?=})|(?=\n)'
          pop: true
        - include: fstring-illegal-single-brace
        - include: fstring-single-brace
        - match: "([bcdeEfFgGnosxX%])(?=})"
          scope: storage.type.format.python
        - match: (\.\d+)
          scope: storage.type.format.python
        - match: (,)
          scope: storage.type.format.python
        - match: (\d+)
          scope: storage.type.format.python
        - match: (\#)
          scope: storage.type.format.python
        - match: "([-+ ])"
          scope: storage.type.format.python
        - match: "([<>=^])"
          scope: storage.type.format.python
        - match: (\w)
          scope: storage.type.format.python
  function-arguments:
    - match: |-
        (?x)
        (?:
          (\()
          (?:\s*(\*\*|\*))?
        )
      captures:
        1: punctuation.definition.arguments.begin.python
        2: keyword.operator.unpacking.arguments.python
      push:
        - meta_content_scope: meta.function-call.arguments.python
        - match: (?=\))(?!\)\s*\()
          pop: true
        - match: |-
            (?x)
            (?:
              (,)
              (?:\s*(\*\*|\*))?
            )
          captures:
            1: punctuation.separator.arguments.python
            2: keyword.operator.unpacking.arguments.python
        - include: lambda-incomplete
        - include: illegal-names
        - match: '\b([[:alpha:]_]\w*)\s*(=)(?!=)'
          captures:
            1: variable.parameter.function-call.python
            2: keyword.operator.assignment.python
        - match: "=(?!=)"
          scope: keyword.operator.assignment.python
        - include: expression
        - match: \s*(\))\s*(\()
          captures:
            1: punctuation.definition.arguments.end.python
            2: punctuation.definition.arguments.begin.python
  function-call:
    - match: |-
        (?x)
        \b(?=
          ([[:alpha:]_]\w*) \s* (\()
        )
      push:
        - meta_scope: meta.function-call.python
        - match: (\))
          captures:
            1: punctuation.definition.arguments.end.python
          pop: true
        - include: special-variables
        - include: function-name
        - include: function-arguments
  function-declaration:
    - match: |-
        (?x)
        \s*
        (?:\b(async) \s+)? \b(def)\s+
          (?=
            [[:alpha:]_][[:word:]]* \s* \(
          )
      captures:
        1: storage.type.function.async.python
        2: storage.type.function.python
      push:
        - meta_scope: meta.function.python
        - match: '(:|(?=[#''"\n]))'
          captures:
            1: punctuation.section.function.begin.python
          pop: true
        - include: function-def-name
        - include: parameters
        - include: line-continuation
        - include: return-annotation
  function-def-name:
    - include: illegal-object-name
    - include: builtin-possible-callables
    - match: |-
        (?x)
        \b ([[:alpha:]_]\w*) \b
      scope: entity.name.function.python
  function-name:
    - include: builtin-possible-callables
    - match: |-
        (?x)
        \b ([[:alpha:]_]\w*) \b
      comment: Some color schemas support meta.function-call.generic scope
      scope: meta.function-call.generic.python
  illegal-anno:
    - match: "->"
      scope: invalid.illegal.annotation.python
  illegal-names:
    - match: |-
        (?x)
        \b(
          and | as | assert | async | await | break | class | continue | def
          | del | elif | else | except | exec | finally | for | from | global
          | if | import | in | is | (?<=\.)lambda | lambda(?=\s*[\.=])
          | nonlocal | not | or | pass | raise | return | try | while | with
          | yield
        )\b
      scope: keyword.control.flow.python
  illegal-object-name:
    - match: \b(True|False|None)\b
      comment: It's illegal to name class or function "True"
      scope: keyword.illegal.name.python
  illegal-operator:
    - match: '&&|\|\||--|\+\+'
      scope: invalid.illegal.operator.python
    - match: "[?$]"
      scope: invalid.illegal.operator.python
    - match: '!\b'
      comment: We don't want `!` to flash when we're typing `!=`
      scope: invalid.illegal.operator.python
  import:
    - match: |-
        (?x)
        \s* \b(from)\b (\s*\.+\s*) (import)?
      captures:
        1: keyword.control.import.python
        3: keyword.control.import.python
    - match: \b(?<!\.)import\b
      scope: keyword.control.import.python
  impossible:
    - match: $.^
      comment: "This is a special rule that should be used where no match is desired. It is not a good idea to match something like '1{0}' because in some cases that can result in infinite loops in token generation. So the rule instead matches and impossible expression to allow a match to fail and move to the next token."
  inheritance-identifier:
    - match: |-
        (?x)
        \b ([[:alpha:]_]\w*) \b
      captures:
        1: entity.other.inherited-class.python
  inheritance-name:
    - include: lambda-incomplete
    - include: builtin-possible-callables
    - include: inheritance-identifier
  item-access:
    - match: |-
        (?x)
        \b(?=
          [[:alpha:]_]\w* \s* \[
        )
      push:
        - meta_scope: meta.item-access.python
        - match: '(\])'
          captures:
            1: punctuation.definition.arguments.end.python
          pop: true
        - include: item-name
        - include: item-index
        - include: expression
  item-index:
    - match: '(\[)'
      captures:
        1: punctuation.definition.arguments.begin.python
      push:
        - meta_content_scope: meta.item-access.arguments.python
        - match: '(?=\])'
          pop: true
        - match: ":"
          scope: punctuation.separator.slice.python
        - include: expression
  item-name:
    - include: special-variables
    - include: builtin-functions
    - include: special-names
    - match: |-
        (?x)
        \b ([[:alpha:]_]\w*) \b
  lambda:
    - match: '((?<=\.)lambda|lambda(?=\s*[\.=]))'
      captures:
        1: keyword.control.flow.python
    - match: '\b(lambda)\s*?(?=[,\n]|$)'
      captures:
        1: storage.type.function.lambda.python
    - match: |-
        (?x)
        \b (lambda) \b
      captures:
        1: storage.type.function.lambda.python
      push:
        - meta_scope: meta.lambda-function.python
        - meta_content_scope: meta.function.lambda.parameters.python
        - match: (:)|(\n)
          captures:
            1: punctuation.section.function.lambda.begin.python
          pop: true
        - match: (\*\*|\*)
          scope: keyword.operator.unpacking.parameter.python
        - include: lambda-nested-incomplete
        - include: illegal-names
        - match: '([[:alpha:]_]\w*)\s*(?:(,)|(?=:|$))'
          captures:
            1: variable.parameter.function.language.python
            2: punctuation.separator.parameters.python
        - include: comments
        - include: backticks
        - include: illegal-anno
        - include: lambda-parameter-with-default
        - include: line-continuation
        - include: illegal-operator
  lambda-incomplete:
    - match: '\blambda(?=\s*[,)])'
      scope: storage.type.function.lambda.python
  lambda-nested-incomplete:
    - match: '\blambda(?=\s*[:,)])'
      scope: storage.type.function.lambda.python
  lambda-parameter-with-default:
    - match: |-
        (?x)
        \b
        ([[:alpha:]_]\w*) \s* (=)
      captures:
        1: variable.parameter.function.language.python
        2: keyword.operator.python
      push:
        - match: (,)|(?=:|$)
          captures:
            1: punctuation.separator.parameters.python
          pop: true
        - include: expression
  line-continuation:
    - match: (\\)\s*(\S.*$\n?)
      captures:
        1: punctuation.separator.continuation.line.python
        2: invalid.illegal.line.continuation.python
    - match: (\\)\s*$\n?
      captures:
        1: punctuation.separator.continuation.line.python
      push:
        - match: |-
            (?x)
            (?=^\s*$)
            |
            (?! (\s* [rR]? (\'\'\'|\"\"\"|\'|\"))
                |
                (\G $)  (?# '\G' is necessary for ST)
            )
          pop: true
        - include: regexp
        - include: string
  list:
    - match: '\['
      captures:
        0: punctuation.definition.list.begin.python
      push:
        - match: '\]'
          captures:
            0: punctuation.definition.list.end.python
          pop: true
        - include: expression
  literal:
    - match: \b(True|False|None|NotImplemented|Ellipsis)\b
      scope: constant.language.python
    - include: number
  loose-default:
    - match: (=)
      captures:
        1: keyword.operator.python
      push:
        - match: (,)|(?=\))
          captures:
            1: punctuation.separator.parameters.python
          pop: true
        - include: expression
  magic-function-names:
    - match: |-
        (?x)
        \b(
          __(?:
            abs | add | aenter | aexit | aiter | and | anext | await
            | bool | call | ceil | cmp | coerce | complex | contains
            | copy | deepcopy | del | delattr | delete | delitem
            | delslice | dir | div | divmod | enter | eq | exit | float
            | floor | floordiv | format | ge | get | getattr
            | getattribute | getinitargs | getitem | getnewargs
            | getslice | getstate | gt | hash | hex | iadd | iand | idiv
            | ifloordiv | ilshift | imod | imul | index | init
            | instancecheck | int | invert | ior | ipow | irshift | isub
            | iter | itruediv | ixor | le | len | long | lshift | lt
            | missing | mod | mul | ne | neg | new | next | nonzero | oct | or
            | pos | pow | radd | rand | rdiv | rdivmod | reduce
            | reduce_ex | repr | reversed | rfloordiv | rlshift | rmod
            | rmul | ror | round | rpow | rrshift | rshift | rsub
            | rtruediv | rxor | set | setattr | setitem | setslice
            | setstate | sizeof | str | sub | subclasscheck | truediv
            | trunc | unicode | xor | matmul | rmatmul | imatmul
            | init_subclass | set_name | fspath | bytes | prepare
          )__
        )\b
      comment: |
        these methods have magic interpretation by python and are generally called
        indirectly through syntactic constructs
      captures:
        1: support.function.magic.python
  magic-names:
    - include: magic-function-names
    - include: magic-variable-names
  magic-variable-names:
    - match: |-
        (?x)
        \b(
          __(?:
            all | bases | builtins | class | code | debug | defaults | dict
            | doc | file | func | kwdefaults | members
            | metaclass | methods | module | mro | name
            | qualname | self | signature | slots | subclasses
            | version | weakref | wrapped | annotations | classcell
            | spec | path | package | future
          )__
        )\b
      comment: magic variables which a class/module may have.
      captures:
        1: support.variable.magic.python
  member-access:
    - match: \.\s*(?!\.)
      push:
        - match: |-
            (?x)
            # stop when you've just read non-whitespace followed by non-word
            # i.e. when finished reading an identifier or function call
            (?<=\S)(?=\W) |
            # stop when seeing the start of something that's not a word,
            # i.e. when seeing a non-identifier
            (^|(?<=\s))(?=[^\\\w\s]) |
            $
          pop: true
        - include: function-call
        - include: member-access-base
  member-access-base:
    - include: magic-names
    - include: illegal-names
    - include: illegal-object-name
    - include: special-names
    - include: line-continuation
    - include: item-access
  member-access-class:
    - match: \.\s*(?!\.)
      push:
        - match: (?<=\S)(?=\W)|$
          pop: true
        - include: call-wrapper-inheritance
        - include: member-access-base
        - include: inheritance-identifier
  number:
    - include: number-float
    - include: number-dec
    - include: number-hex
    - include: number-oct
    - include: number-bin
    - include: number-long
    - match: '\b[0-9]+\w+'
      scope: invalid.illegal.name.python
  number-bin:
    - match: |-
        (?x)
        (?<![\w\.])
          (0[bB]) (_?[01])+
        \b
      scope: constant.numeric.bin.python
      captures:
        1: storage.type.number.python
  number-dec:
    - match: |-
        (?x)
        (?<![\w\.])(?:
            [1-9](?: _?[0-9] )*
            |
            0+
            |
            [0-9](?: _?[0-9] )* ([jJ])
            |
            0 ([0-9]+)(?![eE\.])
        )\b
      scope: constant.numeric.dec.python
      captures:
        1: storage.type.imaginary.number.python
        2: invalid.illegal.dec.python
        3: invalid.illegal.dec.python
  number-float:
    - match: |-
        (?x)
        (?<! \w)(?:
          (?:
            \.[0-9](?: _?[0-9] )*
            |
            [0-9](?: _?[0-9] )* \. [0-9](?: _?[0-9] )*
            |
            [0-9](?: _?[0-9] )* \.
          ) (?: [eE][+-]?[0-9](?: _?[0-9] )* )?
          |
          [0-9](?: _?[0-9] )* (?: [eE][+-]?[0-9](?: _?[0-9] )* )
        )([jJ])?\b
      scope: constant.numeric.float.python
      captures:
        1: storage.type.imaginary.number.python
  number-hex:
    - match: |-
        (?x)
        (?<![\w\.])
          (0[xX]) (_?[0-9a-fA-F])+
        \b
      scope: constant.numeric.hex.python
      captures:
        1: storage.type.number.python
  number-long:
    - match: |-
        (?x)
        (?<![\w\.])
          ([1-9][0-9]* | 0) ([lL])
        \b
      comment: this is to support python2 syntax for long ints
      scope: constant.numeric.bin.python
      captures:
        2: storage.type.number.python
  number-oct:
    - match: |-
        (?x)
        (?<![\w\.])
          (0[oO]) (_?[0-7])+
        \b
      scope: constant.numeric.oct.python
      captures:
        1: storage.type.number.python
  operator:
    - match: |-
        (?x)
            \b(?<!\.)
              (?:
                (and | or | not | in | is)                         (?# 1)
                |
                (for | if | else | await | (?:yield(?:\s+from)?))  (?# 2)
              )
            (?!\s*:)\b

            | (<< | >> | & | \| | \^ | ~)                          (?# 3)

            | (\*\* | \* | \+ | - | % | // | / | @)                (?# 4)

            | (!= | == | >= | <= | < | >)                          (?# 5)
      captures:
        1: keyword.operator.logical.python
        2: keyword.control.flow.python
        3: keyword.operator.bitwise.python
        4: keyword.operator.arithmetic.python
        5: keyword.operator.comparison.python
  parameter-special:
    - match: |-
        (?x)
        \b ((self)|(cls)) \b \s*(?:(,)|(?=\)))
      captures:
        1: variable.parameter.function.language.python
        2: variable.parameter.function.language.special.self.python
        3: variable.parameter.function.language.special.cls.python
        4: punctuation.separator.parameters.python
  parameters:
    - match: (\()
      captures:
        1: punctuation.definition.parameters.begin.python
      push:
        - meta_scope: meta.function.parameters.python
        - match: (\))
          captures:
            1: punctuation.definition.parameters.end.python
          pop: true
        - match: (\*\*|\*)
          scope: keyword.operator.unpacking.parameter.python
        - include: lambda-incomplete
        - include: illegal-names
        - include: illegal-object-name
        - include: parameter-special
        - match: |-
            (?x)
            ([[:alpha:]_]\w*)
              \s* (?: (,) | (?=[)#\n=]))
          captures:
            1: variable.parameter.function.language.python
            2: punctuation.separator.parameters.python
        - include: comments
        - include: loose-default
        - include: annotated-parameter
  punctuation:
    - match: ":"
      scope: punctuation.separator.colon.python
    - match: ","
      scope: punctuation.separator.element.python
  regexp:
    - include: regexp-single-three-line
    - include: regexp-double-three-line
    - include: regexp-single-one-line
    - include: regexp-double-one-line
    - include: fregexp-single-three-line
    - include: fregexp-double-three-line
    - include: fregexp-single-one-line
    - include: fregexp-double-one-line
  regexp-backreference:
    - match: |-
        (?x)
        (\()  (\?P= \w+(?:\s+[[:alnum:]]+)?)  (\))
      scope: meta.backreference.named.regexp
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.backreference.named.begin.regexp
        2: entity.name.tag.named.backreference.regexp
        3: support.other.parenthesis.regexp punctuation.parenthesis.backreference.named.end.regexp
  regexp-backreference-number:
    - match: '(\\[1-9]\d?)'
      scope: meta.backreference.regexp
      captures:
        1: entity.name.tag.backreference.regexp
  regexp-base-common:
    - match: \.
      scope: support.other.match.any.regexp
    - match: \^
      scope: support.other.match.begin.regexp
    - match: \$
      scope: support.other.match.end.regexp
    - match: '[+*?]\??'
      scope: keyword.operator.quantifier.regexp
    - match: \|
      scope: keyword.operator.disjunction.regexp
    - include: regexp-escape-sequence
  regexp-base-expression:
    - include: regexp-quantifier
    - include: regexp-base-common
  regexp-charecter-set-escapes:
    - match: '\\[abfnrtv\\]'
      scope: constant.character.escape.regexp
    - include: regexp-escape-special
    - match: '\\([0-7]{1,3})'
      scope: constant.character.escape.regexp
    - include: regexp-escape-character
    - include: regexp-escape-unicode
    - include: regexp-escape-catchall
  regexp-double-one-line:
    - match: '\b(([uU]r)|([bB]r)|(r[bB]?))(")'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: storage.type.string.python
        5: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.regexp.quoted.single.python
        - match: (")|(?<!\\)(\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: double-one-regexp-expression
  regexp-double-three-line:
    - match: '\b(([uU]r)|([bB]r)|(r[bB]?))(""")'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: storage.type.string.python
        5: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.regexp.quoted.multi.python
        - match: (""")
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: double-three-regexp-expression
  regexp-escape-catchall:
    - match: \\(.|\n)
      scope: constant.character.escape.regexp
  regexp-escape-character:
    - match: |-
        (?x)
        \\ (
              x[0-9A-Fa-f]{2}
              | 0[0-7]{1,2}
              | [0-7]{3}
           )
      scope: constant.character.escape.regexp
  regexp-escape-sequence:
    - include: regexp-escape-special
    - include: regexp-escape-character
    - include: regexp-escape-unicode
    - include: regexp-backreference-number
    - include: regexp-escape-catchall
  regexp-escape-special:
    - match: '\\([AbBdDsSwWZ])'
      scope: support.other.escape.special.regexp
  regexp-escape-unicode:
    - match: |-
        (?x)
        \\ (
              u[0-9A-Fa-f]{4}
              | U[0-9A-Fa-f]{8}
           )
      scope: constant.character.unicode.regexp
  regexp-flags:
    - match: '\(\?[aiLmsux]+\)'
      scope: storage.modifier.flag.regexp
  regexp-quantifier:
    - match: |-
        (?x)
        \{(
          \d+ | \d+,(\d+)? | ,\d+
        )\}
      scope: keyword.operator.quantifier.regexp
  regexp-single-one-line:
    - match: '\b(([uU]r)|([bB]r)|(r[bB]?))(\'')'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: storage.type.string.python
        5: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.regexp.quoted.single.python
        - match: (\')|(?<!\\)(\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  regexp-single-three-line:
    - match: '\b(([uU]r)|([bB]r)|(r[bB]?))(\''\''\'')'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: storage.type.string.python
        5: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.regexp.quoted.multi.python
        - match: (\'\'\')
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
  return-annotation:
    - match: (->)
      captures:
        1: punctuation.separator.annotation.result.python
      push:
        - match: (?=:)
          pop: true
        - include: expression
  round-braces:
    - match: \(
      captures:
        0: punctuation.parenthesis.begin.python
      push:
        - match: \)
          captures:
            0: punctuation.parenthesis.end.python
          pop: true
        - include: expression
  semicolon:
    - match: \;$
      scope: invalid.deprecated.semicolon.python
  single-one-fregexp-conditional:
    - match: '(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)'
      captures:
        0: keyword.operator.conditional.regexp
        1: punctuation.parenthesis.conditional.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  single-one-fregexp-expression:
    - include: fregexp-base-expression
    - include: single-one-regexp-character-set
    - include: single-one-regexp-comments
    - include: regexp-flags
    - include: single-one-regexp-named-group
    - include: regexp-backreference
    - include: single-one-fregexp-lookahead
    - include: single-one-fregexp-lookahead-negative
    - include: single-one-fregexp-lookbehind
    - include: single-one-fregexp-lookbehind-negative
    - include: single-one-fregexp-conditional
    - include: single-one-fregexp-parentheses-non-capturing
    - include: single-one-fregexp-parentheses
  single-one-fregexp-lookahead:
    - match: (\()\?=
      captures:
        0: keyword.operator.lookahead.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  single-one-fregexp-lookahead-negative:
    - match: (\()\?!
      captures:
        0: keyword.operator.lookahead.negative.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  single-one-fregexp-lookbehind:
    - match: (\()\?<=
      captures:
        0: keyword.operator.lookbehind.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  single-one-fregexp-lookbehind-negative:
    - match: (\()\?<!
      captures:
        0: keyword.operator.lookbehind.negative.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  single-one-fregexp-named-group:
    - match: |-
        (?x)
        (\()  (\?P <\w+(?:\s+[[:alnum:]]+)?>)
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp
        2: entity.name.tag.named.group.regexp
      push:
        - meta_scope: meta.named.regexp
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  single-one-fregexp-parentheses:
    - match: \(
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  single-one-fregexp-parentheses-non-capturing:
    - match: '\(\?:'
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-fregexp-expression
  single-one-regexp-character-set:
    - match: |-
        (?x)
        \[ \^? \] (?! .*?\])
    - match: '(\[)(\^)?(\])?'
      captures:
        1: punctuation.character.set.begin.regexp constant.other.set.regexp
        2: keyword.operator.negation.regexp
        3: constant.character.set.regexp
      push:
        - meta_scope: meta.character.set.regexp
        - match: '(\]|(?=\''))|((?=(?<!\\)\n))'
          captures:
            1: punctuation.character.set.end.regexp constant.other.set.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: regexp-charecter-set-escapes
        - match: '[^\n]'
          scope: constant.character.set.regexp
  single-one-regexp-comments:
    - match: '\(\?#'
      captures:
        0: punctuation.comment.begin.regexp
      push:
        - meta_scope: comment.regexp
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: punctuation.comment.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: codetags
  single-one-regexp-conditional:
    - match: '(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)'
      captures:
        0: keyword.operator.conditional.regexp
        1: punctuation.parenthesis.conditional.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  single-one-regexp-expression:
    - include: regexp-base-expression
    - include: single-one-regexp-character-set
    - include: single-one-regexp-comments
    - include: regexp-flags
    - include: single-one-regexp-named-group
    - include: regexp-backreference
    - include: single-one-regexp-lookahead
    - include: single-one-regexp-lookahead-negative
    - include: single-one-regexp-lookbehind
    - include: single-one-regexp-lookbehind-negative
    - include: single-one-regexp-conditional
    - include: single-one-regexp-parentheses-non-capturing
    - include: single-one-regexp-parentheses
  single-one-regexp-lookahead:
    - match: (\()\?=
      captures:
        0: keyword.operator.lookahead.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  single-one-regexp-lookahead-negative:
    - match: (\()\?!
      captures:
        0: keyword.operator.lookahead.negative.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  single-one-regexp-lookbehind:
    - match: (\()\?<=
      captures:
        0: keyword.operator.lookbehind.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  single-one-regexp-lookbehind-negative:
    - match: (\()\?<!
      captures:
        0: keyword.operator.lookbehind.negative.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  single-one-regexp-named-group:
    - match: |-
        (?x)
        (\()  (\?P <\w+(?:\s+[[:alnum:]]+)?>)
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp
        2: entity.name.tag.named.group.regexp
      push:
        - meta_scope: meta.named.regexp
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  single-one-regexp-parentheses:
    - match: \(
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  single-one-regexp-parentheses-non-capturing:
    - match: '\(\?:'
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp
      push:
        - match: (\)|(?=\'))|((?=(?<!\\)\n))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-one-regexp-expression
  single-three-fregexp-conditional:
    - match: '(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)'
      captures:
        0: keyword.operator.conditional.regexp
        1: punctuation.parenthesis.conditional.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
        - include: comments-string-single-three
  single-three-fregexp-expression:
    - include: fregexp-base-expression
    - include: single-three-regexp-character-set
    - include: single-three-regexp-comments
    - include: regexp-flags
    - include: single-three-regexp-named-group
    - include: regexp-backreference
    - include: single-three-fregexp-lookahead
    - include: single-three-fregexp-lookahead-negative
    - include: single-three-fregexp-lookbehind
    - include: single-three-fregexp-lookbehind-negative
    - include: single-three-fregexp-conditional
    - include: single-three-fregexp-parentheses-non-capturing
    - include: single-three-fregexp-parentheses
    - include: comments-string-single-three
  single-three-fregexp-lookahead:
    - match: (\()\?=
      captures:
        0: keyword.operator.lookahead.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
        - include: comments-string-single-three
  single-three-fregexp-lookahead-negative:
    - match: (\()\?!
      captures:
        0: keyword.operator.lookahead.negative.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
        - include: comments-string-single-three
  single-three-fregexp-lookbehind:
    - match: (\()\?<=
      captures:
        0: keyword.operator.lookbehind.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
        - include: comments-string-single-three
  single-three-fregexp-lookbehind-negative:
    - match: (\()\?<!
      captures:
        0: keyword.operator.lookbehind.negative.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
        - include: comments-string-single-three
  single-three-fregexp-named-group:
    - match: |-
        (?x)
        (\()  (\?P <\w+(?:\s+[[:alnum:]]+)?>)
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp
        2: entity.name.tag.named.group.regexp
      push:
        - meta_scope: meta.named.regexp
        - match: (\)|(?=\'\'\'))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
        - include: comments-string-single-three
  single-three-fregexp-parentheses:
    - match: \(
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
        - include: comments-string-single-three
  single-three-fregexp-parentheses-non-capturing:
    - match: '\(\?:'
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-fregexp-expression
        - include: comments-string-single-three
  single-three-regexp-character-set:
    - match: |-
        (?x)
        \[ \^? \] (?! .*?\])
    - match: '(\[)(\^)?(\])?'
      captures:
        1: punctuation.character.set.begin.regexp constant.other.set.regexp
        2: keyword.operator.negation.regexp
        3: constant.character.set.regexp
      push:
        - meta_scope: meta.character.set.regexp
        - match: '(\]|(?=\''\''\''))'
          captures:
            1: punctuation.character.set.end.regexp constant.other.set.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: regexp-charecter-set-escapes
        - match: '[^\n]'
          scope: constant.character.set.regexp
  single-three-regexp-comments:
    - match: '\(\?#'
      captures:
        0: punctuation.comment.begin.regexp
      push:
        - meta_scope: comment.regexp
        - match: (\)|(?=\'\'\'))
          captures:
            1: punctuation.comment.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: codetags
  single-three-regexp-conditional:
    - match: '(\()\?\((\w+(?:\s+[[:alnum:]]+)?|\d+)\)'
      captures:
        0: keyword.operator.conditional.regexp
        1: punctuation.parenthesis.conditional.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
        - include: comments-string-single-three
  single-three-regexp-expression:
    - include: regexp-base-expression
    - include: single-three-regexp-character-set
    - include: single-three-regexp-comments
    - include: regexp-flags
    - include: single-three-regexp-named-group
    - include: regexp-backreference
    - include: single-three-regexp-lookahead
    - include: single-three-regexp-lookahead-negative
    - include: single-three-regexp-lookbehind
    - include: single-three-regexp-lookbehind-negative
    - include: single-three-regexp-conditional
    - include: single-three-regexp-parentheses-non-capturing
    - include: single-three-regexp-parentheses
    - include: comments-string-single-three
  single-three-regexp-lookahead:
    - match: (\()\?=
      captures:
        0: keyword.operator.lookahead.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
        - include: comments-string-single-three
  single-three-regexp-lookahead-negative:
    - match: (\()\?!
      captures:
        0: keyword.operator.lookahead.negative.regexp
        1: punctuation.parenthesis.lookahead.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
        - include: comments-string-single-three
  single-three-regexp-lookbehind:
    - match: (\()\?<=
      captures:
        0: keyword.operator.lookbehind.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
        - include: comments-string-single-three
  single-three-regexp-lookbehind-negative:
    - match: (\()\?<!
      captures:
        0: keyword.operator.lookbehind.negative.regexp
        1: punctuation.parenthesis.lookbehind.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
        - include: comments-string-single-three
  single-three-regexp-named-group:
    - match: |-
        (?x)
        (\()  (\?P <\w+(?:\s+[[:alnum:]]+)?>)
      captures:
        1: support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp
        2: entity.name.tag.named.group.regexp
      push:
        - meta_scope: meta.named.regexp
        - match: (\)|(?=\'\'\'))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
        - include: comments-string-single-three
  single-three-regexp-parentheses:
    - match: \(
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
        - include: comments-string-single-three
  single-three-regexp-parentheses-non-capturing:
    - match: '\(\?:'
      captures:
        0: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp
      push:
        - match: (\)|(?=\'\'\'))
          captures:
            1: support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp
            2: invalid.illegal.newline.python
          pop: true
        - include: single-three-regexp-expression
        - include: comments-string-single-three
  special-names:
    - match: |-
        (?x)
        \b
          # we want to see "enough", meaning 2 or more upper-case
          # letters in the beginning of the constant
          #
          # for more details refer to:
          #   https://github.com/MagicStack/MagicPython/issues/42
          (
            _* [[:upper:]] [_\d]* [[:upper:]]
          )
          [[:upper:]\d]* (_\w*)?
        \b
      scope: constant.other.caps.python
  special-variables:
    - match: |-
        (?x)
        \b (?<!\.) (?:
          (self) | (cls)
        )\b
      captures:
        1: variable.language.special.self.python
        2: variable.language.special.cls.python
  statement:
    - include: import
    - include: class-declaration
    - include: function-declaration
    - include: statement-keyword
    - include: assignment-operator
    - include: decorator
    - include: docstring-statement
    - include: semicolon
  statement-keyword:
    - match: \b((async\s+)?\s*def)\b
      scope: storage.type.function.python
    - match: |-
        (?x)
        \b(?<!\.)(
          as | async | continue | del | assert | break | finally | for
          | from | elif | else | if | except | pass | raise
          | return | try | while | with
        )\b
      scope: keyword.control.flow.python
    - match: |-
        (?x)
        \b(?<!\.)(
          global | nonlocal
        )\b
      scope: storage.modifier.declaration.python
    - match: \b(?<!\.)(class)\b
      scope: storage.type.class.python
  string:
    - include: string-quoted-multi-line
    - include: string-quoted-single-line
    - include: string-bin-quoted-multi-line
    - include: string-bin-quoted-single-line
    - include: string-raw-quoted-multi-line
    - include: string-raw-quoted-single-line
    - include: string-raw-bin-quoted-multi-line
    - include: string-raw-bin-quoted-single-line
    - include: fstring-fnorm-quoted-multi-line
    - include: fstring-fnorm-quoted-single-line
    - include: fstring-normf-quoted-multi-line
    - include: fstring-normf-quoted-single-line
    - include: fstring-raw-quoted-multi-line
    - include: fstring-raw-quoted-single-line
  string-bin-quoted-multi-line:
    - match: '(\b[bB])(''''''|""")'
      captures:
        1: storage.type.string.python
        2: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.binary.multi.python
        - match: (\2)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-entity
  string-bin-quoted-single-line:
    - match: '(\b[bB])(([''"]))'
      captures:
        1: storage.type.string.python
        2: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.binary.single.python
        - match: (\2)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-entity
  string-brace-formatting:
    - match: |-
        (?x)
        (?:
          {{ | }}
          | (?:
            {
              \w*? (\.[[:alpha:]_]\w*? | \[[^\]'"]+\])*?
              (![rsa])?
              ( : \w? [<>=^]? [-+ ]? \#?
                \d* ,? (\.\d+)? [bcdeEfFgGnosxX%]? )?
            })
        )
      scope: constant.character.format.placeholder.other.python
      captures:
        2: storage.type.format.python
        3: storage.type.format.python
    - match: |-
        (?x)
        \{
          \w*? (\.[[:alpha:]_]\w*? | \[[^\]'"]+\])*?
          (![rsa])?
          (:)
            (?=[^'"}\n]*\})
      captures:
        2: storage.type.format.python
        3: storage.type.format.python
      push:
        - meta_scope: constant.character.format.placeholder.other.python
        - match: '\}'
          pop: true
        - match: '(?x) \{ [^''"}\n]*? \} (?=.*?\})'
  string-consume-escape:
    - match: '\\[''"\n\\]'
  string-entity:
    - include: escape-sequence
    - include: string-line-continuation
    - include: string-formatting
  string-formatting:
    - match: |-
        (?x)
        % (\([\w\s]*\))?
          [-+#0 ]*
          (\d+|\*)? (\.(\d+|\*))?
          ([hlL])?
          [diouxXeEfFgGcrsa%]
      scope: constant.character.format.placeholder.other.python
  string-line-continuation:
    - match: \\$
      scope: constant.language.python
  string-multi-bad-brace1-formatting-raw:
    - match: |-
        (?x)
        (?= \{%
              ( .*? (?!'''|""") )
            %\}
        )
      comment: "template using {% ... %}"
      push:
        - match: (?='''|""")
          pop: true
        - include: string-consume-escape
  string-multi-bad-brace1-formatting-unicode:
    - match: |-
        (?x)
        (?= \{%
              ( .*? (?!'''|""") )
            %\}
        )
      comment: "template using {% ... %}"
      push:
        - match: (?='''|""")
          pop: true
        - include: escape-sequence-unicode
        - include: escape-sequence
        - include: string-line-continuation
  string-multi-bad-brace2-formatting-raw:
    - match: |-
        (?x)
        (?!\{\{)
        (?= \{ (
                  \w*? (?!'''|""") [^!:\.\[}\w]
               )
            .*?(?!'''|""")
            \}
        )
      comment: odd format or format-like syntax
      push:
        - match: (?='''|""")
          pop: true
        - include: string-consume-escape
        - include: string-formatting
  string-multi-bad-brace2-formatting-unicode:
    - match: |-
        (?x)
        (?!\{\{)
        (?= \{ (
                  \w*? (?!'''|""") [^!:\.\[}\w]
               )
            .*?(?!'''|""")
            \}
        )
      comment: odd format or format-like syntax
      push:
        - match: (?='''|""")
          pop: true
        - include: escape-sequence-unicode
        - include: string-entity
  string-quoted-multi-line:
    - match: '(\b[rR](?=[uU]))?([uU])?(''''''|""")'
      captures:
        1: invalid.illegal.prefix.python
        2: storage.type.string.python
        3: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.multi.python
        - match: (\3)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-multi-bad-brace1-formatting-unicode
        - include: string-multi-bad-brace2-formatting-unicode
        - include: string-unicode-guts
  string-quoted-single-line:
    - match: '(\b[rR](?=[uU]))?([uU])?(([''"]))'
      captures:
        1: invalid.illegal.prefix.python
        2: storage.type.string.python
        3: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.single.python
        - match: (\3)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-single-bad-brace1-formatting-unicode
        - include: string-single-bad-brace2-formatting-unicode
        - include: string-unicode-guts
  string-raw-bin-guts:
    - include: string-consume-escape
    - include: string-formatting
  string-raw-bin-quoted-multi-line:
    - match: '(\b(?:R[bB]|[bB]R))(''''''|""")'
      captures:
        1: storage.type.string.python
        2: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.raw.binary.multi.python
        - match: (\2)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-raw-bin-guts
  string-raw-bin-quoted-single-line:
    - match: '(\b(?:R[bB]|[bB]R))(([''"]))'
      captures:
        1: storage.type.string.python
        2: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.raw.binary.single.python
        - match: (\2)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-raw-bin-guts
  string-raw-guts:
    - include: string-consume-escape
    - include: string-formatting
    - include: string-brace-formatting
  string-raw-quoted-multi-line:
    - match: '\b(([uU]R)|(R))(''''''|""")'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.raw.multi.python
        - match: (\4)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-multi-bad-brace1-formatting-raw
        - include: string-multi-bad-brace2-formatting-raw
        - include: string-raw-guts
  string-raw-quoted-single-line:
    - match: '\b(([uU]R)|(R))(([''"]))'
      captures:
        2: invalid.deprecated.prefix.python
        3: storage.type.string.python
        4: punctuation.definition.string.begin.python
      push:
        - meta_scope: string.quoted.raw.single.python
        - match: (\4)|((?<!\\)\n)
          captures:
            1: punctuation.definition.string.end.python
            2: invalid.illegal.newline.python
          pop: true
        - include: string-single-bad-brace1-formatting-raw
        - include: string-single-bad-brace2-formatting-raw
        - include: string-raw-guts
  string-single-bad-brace1-formatting-raw:
    - match: |-
        (?x)
        (?= \{%
              ( .*? (?!(['"])|((?<!\\)\n)) )
            %\}
        )
      comment: "template using {% ... %}"
      push:
        - match: '(?=([''"])|((?<!\\)\n))'
          pop: true
        - include: string-consume-escape
  string-single-bad-brace1-formatting-unicode:
    - match: |-
        (?x)
        (?= \{%
              ( .*? (?!(['"])|((?<!\\)\n)) )
            %\}
        )
      comment: "template using {% ... %}"
      push:
        - match: '(?=([''"])|((?<!\\)\n))'
          pop: true
        - include: escape-sequence-unicode
        - include: escape-sequence
        - include: string-line-continuation
  string-single-bad-brace2-formatting-raw:
    - match: |-
        (?x)
        (?!\{\{)
        (?= \{ (
                  \w*? (?!(['"])|((?<!\\)\n)) [^!:\.\[}\w]
               )
            .*?(?!(['"])|((?<!\\)\n))
            \}
        )
      comment: odd format or format-like syntax
      push:
        - match: '(?=([''"])|((?<!\\)\n))'
          pop: true
        - include: string-consume-escape
        - include: string-formatting
  string-single-bad-brace2-formatting-unicode:
    - match: |-
        (?x)
        (?!\{\{)
        (?= \{ (
                  \w*? (?!(['"])|((?<!\\)\n)) [^!:\.\[}\w]
               )
            .*?(?!(['"])|((?<!\\)\n))
            \}
        )
      comment: odd format or format-like syntax
      push:
        - match: '(?=([''"])|((?<!\\)\n))'
          pop: true
        - include: escape-sequence-unicode
        - include: string-entity
  string-unicode-guts:
    - include: escape-sequence-unicode
    - include: string-entity
    - include: string-brace-formatting
