// !!! autogenerated; do not edit !!!



describe("Grammar Tests", function() {
  var grammar = null;
  beforeEach(function() {
    waitsForPromise(function() {
      return atom.packages.activatePackage("MagicPython")
    });
    runs(function() {
      grammar = atom.grammars.grammarForScopeName("source.regexp.python")
    });
  });


  it("test/regexp/comments1.re", 
    function() {
      tokens = grammar.tokenizeLines("foo(?#comment)bar")
      expect(tokens[0][0].value).toBe("foo");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][1].value).toBe("(?#");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","comment.regexp","punctuation.comment.begin.regexp"]);
      expect(tokens[0][2].value).toBe("comment");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","comment.regexp"]);
      expect(tokens[0][3].value).toBe(")");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","comment.regexp","punctuation.comment.end.regexp"]);
      expect(tokens[0][4].value).toBe("bar");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python"]);
    });

  it("test/regexp/comments2.re", 
    function() {
      tokens = grammar.tokenizeLines("(?x)\n    foo     (?#\ncomment 1\n            ) bar\n    baz     (?#comment 2)")
      expect(tokens[0][0].value).toBe("(?x)");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","storage.modifier.flag.regexp"]);
      expect(tokens[1][0].value).toBe("    foo     ");
      expect(tokens[1][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[1][1].value).toBe("(?#");
      expect(tokens[1][1].scopes).toEqual(["source.regexp.python","comment.regexp","punctuation.comment.begin.regexp"]);
      expect(tokens[2][0].value).toBe("comment 1");
      expect(tokens[2][0].scopes).toEqual(["source.regexp.python","comment.regexp"]);
      expect(tokens[3][0].value).toBe("            ");
      expect(tokens[3][0].scopes).toEqual(["source.regexp.python","comment.regexp"]);
      expect(tokens[3][1].value).toBe(")");
      expect(tokens[3][1].scopes).toEqual(["source.regexp.python","comment.regexp","punctuation.comment.end.regexp"]);
      expect(tokens[3][2].value).toBe(" bar");
      expect(tokens[3][2].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[4][0].value).toBe("    baz     ");
      expect(tokens[4][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[4][1].value).toBe("(?#");
      expect(tokens[4][1].scopes).toEqual(["source.regexp.python","comment.regexp","punctuation.comment.begin.regexp"]);
      expect(tokens[4][2].value).toBe("comment 2");
      expect(tokens[4][2].scopes).toEqual(["source.regexp.python","comment.regexp"]);
      expect(tokens[4][3].value).toBe(")");
      expect(tokens[4][3].scopes).toEqual(["source.regexp.python","comment.regexp","punctuation.comment.end.regexp"]);
    });

  it("test/regexp/comments3.re", 
    function() {
      tokens = grammar.tokenizeLines("foo(?#NOTE:comment)bar")
      expect(tokens[0][0].value).toBe("foo");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][1].value).toBe("(?#");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","comment.regexp","punctuation.comment.begin.regexp"]);
      expect(tokens[0][2].value).toBe("NOTE");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","comment.regexp","keyword.codetag.notation.python"]);
      expect(tokens[0][3].value).toBe(":comment");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","comment.regexp"]);
      expect(tokens[0][4].value).toBe(")");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","comment.regexp","punctuation.comment.end.regexp"]);
      expect(tokens[0][5].value).toBe("bar");
      expect(tokens[0][5].scopes).toEqual(["source.regexp.python"]);
    });

  it("test/regexp/conditional1.re", 
    function() {
      tokens = grammar.tokenizeLines("(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)")
      expect(tokens[0][0].value).toBe("(");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.begin.regexp support.other.parenthesis.regexp"]);
      expect(tokens[0][1].value).toBe("<");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][2].value).toBe(")");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.end.regexp support.other.parenthesis.regexp"]);
      expect(tokens[0][3].value).toBe("?");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][4].value).toBe("(");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.begin.regexp support.other.parenthesis.regexp"]);
      expect(tokens[0][5].value).toBe("\\w");
      expect(tokens[0][5].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][6].value).toBe("+");
      expect(tokens[0][6].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][7].value).toBe("@");
      expect(tokens[0][7].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][8].value).toBe("\\w");
      expect(tokens[0][8].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][9].value).toBe("+");
      expect(tokens[0][9].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][10].value).toBe("(?:");
      expect(tokens[0][10].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.non-capturing.begin.regexp support.other.parenthesis.regexp"]);
      expect(tokens[0][11].value).toBe("\\.");
      expect(tokens[0][11].scopes).toEqual(["source.regexp.python","constant.character.escape.regexp"]);
      expect(tokens[0][12].value).toBe("\\w");
      expect(tokens[0][12].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][13].value).toBe("+");
      expect(tokens[0][13].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][14].value).toBe(")");
      expect(tokens[0][14].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.non-capturing.end.regexp support.other.parenthesis.regexp"]);
      expect(tokens[0][15].value).toBe("+");
      expect(tokens[0][15].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][16].value).toBe(")");
      expect(tokens[0][16].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.end.regexp support.other.parenthesis.regexp"]);
      expect(tokens[0][17].value).toBe("(");
      expect(tokens[0][17].scopes).toEqual(["source.regexp.python","keyword.operator.conditional.regexp","punctuation.parenthesis.conditional.begin.regexp"]);
      expect(tokens[0][18].value).toBe("?(1)");
      expect(tokens[0][18].scopes).toEqual(["source.regexp.python","keyword.operator.conditional.regexp"]);
      expect(tokens[0][19].value).toBe(">");
      expect(tokens[0][19].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][20].value).toBe("|");
      expect(tokens[0][20].scopes).toEqual(["source.regexp.python","keyword.operator.disjunction.regexp"]);
      expect(tokens[0][21].value).toBe("$");
      expect(tokens[0][21].scopes).toEqual(["source.regexp.python","support.other.match.end.regexp"]);
      expect(tokens[0][22].value).toBe(")");
      expect(tokens[0][22].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.conditional.end.regexp keyword.operator.conditional.negative.regexp"]);
    });

  it("test/regexp/escaping1.re", 
    function() {
      tokens = grammar.tokenizeLines("foo\\\nbar")
      expect(tokens[0][0].value).toBe("foo");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][1].value).toBe("\\");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","constant.character.escape.regexp"]);
      expect(tokens[1][0].value).toBe("bar");
      expect(tokens[1][0].scopes).toEqual(["source.regexp.python"]);
    });

  it("test/regexp/escaping2.re", 
    function() {
      tokens = grammar.tokenizeLines("start\\A\\b\\B\\d\\D\\s\\S\\w\\W\\Z\\\\\\1\\01\\1111\\0011\\xfab\\u123fb\\U1234aaaab\\c")
      expect(tokens[0][0].value).toBe("start");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][1].value).toBe("\\A");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][2].value).toBe("\\b");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][3].value).toBe("\\B");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][4].value).toBe("\\d");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][5].value).toBe("\\D");
      expect(tokens[0][5].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][6].value).toBe("\\s");
      expect(tokens[0][6].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][7].value).toBe("\\S");
      expect(tokens[0][7].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][8].value).toBe("\\w");
      expect(tokens[0][8].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][9].value).toBe("\\W");
      expect(tokens[0][9].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][10].value).toBe("\\Z");
      expect(tokens[0][10].scopes).toEqual(["source.regexp.python","support.other.escape.special.regexp"]);
      expect(tokens[0][11].value).toBe("\\\\");
      expect(tokens[0][11].scopes).toEqual(["source.regexp.python","constant.character.escape.regexp"]);
      expect(tokens[0][12].value).toBe("\\1");
      expect(tokens[0][12].scopes).toEqual(["source.regexp.python","meta.backreference.regexp","entity.name.tag.backreference.regexp"]);
      expect(tokens[0][13].value).toBe("\\01");
      expect(tokens[0][13].scopes).toEqual(["source.regexp.python","constant.character.escape.regexp"]);
      expect(tokens[0][14].value).toBe("\\111");
      expect(tokens[0][14].scopes).toEqual(["source.regexp.python","constant.character.escape.regexp"]);
      expect(tokens[0][15].value).toBe("1");
      expect(tokens[0][15].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][16].value).toBe("\\001");
      expect(tokens[0][16].scopes).toEqual(["source.regexp.python","constant.character.escape.regexp"]);
      expect(tokens[0][17].value).toBe("1");
      expect(tokens[0][17].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][18].value).toBe("\\xfa");
      expect(tokens[0][18].scopes).toEqual(["source.regexp.python","constant.character.escape.regexp"]);
      expect(tokens[0][19].value).toBe("b");
      expect(tokens[0][19].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][20].value).toBe("\\u123f");
      expect(tokens[0][20].scopes).toEqual(["source.regexp.python","constant.character.unicode.regexp"]);
      expect(tokens[0][21].value).toBe("b");
      expect(tokens[0][21].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][22].value).toBe("\\U1234aaaa");
      expect(tokens[0][22].scopes).toEqual(["source.regexp.python","constant.character.unicode.regexp"]);
      expect(tokens[0][23].value).toBe("b");
      expect(tokens[0][23].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][24].value).toBe("\\c");
      expect(tokens[0][24].scopes).toEqual(["source.regexp.python","constant.character.escape.regexp"]);
    });

  it("test/regexp/escaping3.re", 
    function() {
      tokens = grammar.tokenizeLines("[start\\A\\b\\B\\d\\D\\s\\S\\w\\W\\Z\\\\\\1\\01\\1111\\0011\\xfab\\u123fb\\U1234aaaab\\c]")
      expect(tokens[0][0].value).toBe("[");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.begin.regexp"]);
      expect(tokens[0][1].value).toBe("s");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][2].value).toBe("t");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][3].value).toBe("a");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][4].value).toBe("r");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][5].value).toBe("t");
      expect(tokens[0][5].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][6].value).toBe("\\A");
      expect(tokens[0][6].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][7].value).toBe("\\b");
      expect(tokens[0][7].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][8].value).toBe("\\B");
      expect(tokens[0][8].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][9].value).toBe("\\d");
      expect(tokens[0][9].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][10].value).toBe("\\D");
      expect(tokens[0][10].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][11].value).toBe("\\s");
      expect(tokens[0][11].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][12].value).toBe("\\S");
      expect(tokens[0][12].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][13].value).toBe("\\w");
      expect(tokens[0][13].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][14].value).toBe("\\W");
      expect(tokens[0][14].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][15].value).toBe("\\Z");
      expect(tokens[0][15].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][16].value).toBe("\\\\");
      expect(tokens[0][16].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][17].value).toBe("\\1");
      expect(tokens[0][17].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][18].value).toBe("\\01");
      expect(tokens[0][18].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][19].value).toBe("\\111");
      expect(tokens[0][19].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][20].value).toBe("1");
      expect(tokens[0][20].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][21].value).toBe("\\001");
      expect(tokens[0][21].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][22].value).toBe("1");
      expect(tokens[0][22].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][23].value).toBe("\\xfa");
      expect(tokens[0][23].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][24].value).toBe("b");
      expect(tokens[0][24].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][25].value).toBe("\\u123f");
      expect(tokens[0][25].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.unicode.regexp"]);
      expect(tokens[0][26].value).toBe("b");
      expect(tokens[0][26].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][27].value).toBe("\\U1234aaaa");
      expect(tokens[0][27].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.unicode.regexp"]);
      expect(tokens[0][28].value).toBe("b");
      expect(tokens[0][28].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][29].value).toBe("\\c");
      expect(tokens[0][29].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][30].value).toBe("]");
      expect(tokens[0][30].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.end.regexp"]);
    });

  it("test/regexp/escaping4.re", 
    function() {
      tokens = grammar.tokenizeLines("[start\\a\\b\\c\\d\\f\\n\\r\\t\\v]")
      expect(tokens[0][0].value).toBe("[");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.begin.regexp"]);
      expect(tokens[0][1].value).toBe("s");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][2].value).toBe("t");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][3].value).toBe("a");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][4].value).toBe("r");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][5].value).toBe("t");
      expect(tokens[0][5].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][6].value).toBe("\\a");
      expect(tokens[0][6].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][7].value).toBe("\\b");
      expect(tokens[0][7].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][8].value).toBe("\\c");
      expect(tokens[0][8].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][9].value).toBe("\\d");
      expect(tokens[0][9].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","support.other.escape.special.regexp"]);
      expect(tokens[0][10].value).toBe("\\f");
      expect(tokens[0][10].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][11].value).toBe("\\n");
      expect(tokens[0][11].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][12].value).toBe("\\r");
      expect(tokens[0][12].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][13].value).toBe("\\t");
      expect(tokens[0][13].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][14].value).toBe("\\v");
      expect(tokens[0][14].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][15].value).toBe("]");
      expect(tokens[0][15].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.end.regexp"]);
    });

  it("test/regexp/flags1.re", 
    function() {
      tokens = grammar.tokenizeLines("(?aiLmsux)foo")
      expect(tokens[0][0].value).toBe("(?aiLmsux)");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","storage.modifier.flag.regexp"]);
      expect(tokens[0][1].value).toBe("foo");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python"]);
    });

  it("test/regexp/group1.re", 
    function() {
      tokens = grammar.tokenizeLines("(?x)\n    (?:not) (foo)\n        .* (?P<bar>BAR)\n    \\1 (?P=bar)")
      expect(tokens[0][0].value).toBe("(?x)");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","storage.modifier.flag.regexp"]);
      expect(tokens[1][0].value).toBe("    ");
      expect(tokens[1][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[1][1].value).toBe("(?:");
      expect(tokens[1][1].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.non-capturing.begin.regexp support.other.parenthesis.regexp"]);
      expect(tokens[1][2].value).toBe("not");
      expect(tokens[1][2].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[1][3].value).toBe(")");
      expect(tokens[1][3].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.non-capturing.end.regexp support.other.parenthesis.regexp"]);
      expect(tokens[1][4].value).toBe(" ");
      expect(tokens[1][4].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[1][5].value).toBe("(");
      expect(tokens[1][5].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.begin.regexp support.other.parenthesis.regexp"]);
      expect(tokens[1][6].value).toBe("foo");
      expect(tokens[1][6].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[1][7].value).toBe(")");
      expect(tokens[1][7].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.end.regexp support.other.parenthesis.regexp"]);
      expect(tokens[2][0].value).toBe("        ");
      expect(tokens[2][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[2][1].value).toBe(".");
      expect(tokens[2][1].scopes).toEqual(["source.regexp.python","support.other.match.any.regexp"]);
      expect(tokens[2][2].value).toBe("*");
      expect(tokens[2][2].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[2][3].value).toBe(" ");
      expect(tokens[2][3].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[2][4].value).toBe("(");
      expect(tokens[2][4].scopes).toEqual(["source.regexp.python","meta.named.regexp","punctuation.parenthesis.named.begin.regexp support.other.parenthesis.regexp"]);
      expect(tokens[2][5].value).toBe("?P<bar>");
      expect(tokens[2][5].scopes).toEqual(["source.regexp.python","meta.named.regexp","entity.name.tag.named.group.regexp"]);
      expect(tokens[2][6].value).toBe("BAR");
      expect(tokens[2][6].scopes).toEqual(["source.regexp.python","meta.named.regexp"]);
      expect(tokens[2][7].value).toBe(")");
      expect(tokens[2][7].scopes).toEqual(["source.regexp.python","meta.named.regexp","punctuation.parenthesis.named.end.regexp support.other.parenthesis.regexp"]);
      expect(tokens[3][0].value).toBe("    ");
      expect(tokens[3][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[3][1].value).toBe("\\1");
      expect(tokens[3][1].scopes).toEqual(["source.regexp.python","meta.backreference.regexp","entity.name.tag.backreference.regexp"]);
      expect(tokens[3][2].value).toBe(" ");
      expect(tokens[3][2].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[3][3].value).toBe("(");
      expect(tokens[3][3].scopes).toEqual(["source.regexp.python","meta.backreference.named.regexp","punctuation.parenthesis.backreference.named.begin.regexp support.other.parenthesis.regexp"]);
      expect(tokens[3][4].value).toBe("?P=bar");
      expect(tokens[3][4].scopes).toEqual(["source.regexp.python","meta.backreference.named.regexp","entity.name.tag.named.backreference.regexp"]);
      expect(tokens[3][5].value).toBe(")");
      expect(tokens[3][5].scopes).toEqual(["source.regexp.python","meta.backreference.named.regexp","punctuation.parenthesis.backreference.named.end.regexp support.other.parenthesis.regexp"]);
    });

  it("test/regexp/lookahead1.re", 
    function() {
      tokens = grammar.tokenizeLines("foo(?=bar)")
      expect(tokens[0][0].value).toBe("foo");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][1].value).toBe("(");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","keyword.operator.lookahead.regexp","punctuation.parenthesis.lookahead.begin.regexp"]);
      expect(tokens[0][2].value).toBe("?=");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","keyword.operator.lookahead.regexp"]);
      expect(tokens[0][3].value).toBe("bar");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][4].value).toBe(")");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.lookahead.end.regexp keyword.operator.lookahead.regexp"]);
    });

  it("test/regexp/lookahead2.re", 
    function() {
      tokens = grammar.tokenizeLines("foo(?!bar)")
      expect(tokens[0][0].value).toBe("foo");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][1].value).toBe("(");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","keyword.operator.lookahead.negative.regexp","punctuation.parenthesis.lookahead.begin.regexp"]);
      expect(tokens[0][2].value).toBe("?!");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","keyword.operator.lookahead.negative.regexp"]);
      expect(tokens[0][3].value).toBe("bar");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][4].value).toBe(")");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.lookahead.end.regexp keyword.operator.lookahead.negative.regexp"]);
    });

  it("test/regexp/lookbehind1.re", 
    function() {
      tokens = grammar.tokenizeLines("(?<=foo)bar")
      expect(tokens[0][0].value).toBe("(");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","keyword.operator.lookbehind.regexp","punctuation.parenthesis.lookbehind.begin.regexp"]);
      expect(tokens[0][1].value).toBe("?<=");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","keyword.operator.lookbehind.regexp"]);
      expect(tokens[0][2].value).toBe("foo");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][3].value).toBe(")");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.lookbehind.end.regexp keyword.operator.lookbehind.regexp"]);
      expect(tokens[0][4].value).toBe("bar");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python"]);
    });

  it("test/regexp/lookbehind2.re", 
    function() {
      tokens = grammar.tokenizeLines("(?<!foo)bar")
      expect(tokens[0][0].value).toBe("(");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","keyword.operator.lookbehind.negative.regexp","punctuation.parenthesis.lookbehind.begin.regexp"]);
      expect(tokens[0][1].value).toBe("?<!");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","keyword.operator.lookbehind.negative.regexp"]);
      expect(tokens[0][2].value).toBe("foo");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][3].value).toBe(")");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","punctuation.parenthesis.lookbehind.end.regexp keyword.operator.lookbehind.negative.regexp"]);
      expect(tokens[0][4].value).toBe("bar");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python"]);
    });

  it("test/regexp/quantifiers1.re", 
    function() {
      tokens = grammar.tokenizeLines("^a+b*c?d*?e+?f??$")
      expect(tokens[0][0].value).toBe("^");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","support.other.match.begin.regexp"]);
      expect(tokens[0][1].value).toBe("a");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][2].value).toBe("+");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][3].value).toBe("b");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][4].value).toBe("*");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][5].value).toBe("c");
      expect(tokens[0][5].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][6].value).toBe("?");
      expect(tokens[0][6].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][7].value).toBe("d");
      expect(tokens[0][7].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][8].value).toBe("*?");
      expect(tokens[0][8].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][9].value).toBe("e");
      expect(tokens[0][9].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][10].value).toBe("+?");
      expect(tokens[0][10].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][11].value).toBe("f");
      expect(tokens[0][11].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][12].value).toBe("??");
      expect(tokens[0][12].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][13].value).toBe("$");
      expect(tokens[0][13].scopes).toEqual(["source.regexp.python","support.other.match.end.regexp"]);
    });

  it("test/regexp/quantifiers2.re", 
    function() {
      tokens = grammar.tokenizeLines("^a{10}b{,10}c{10,}d{10,100}$")
      expect(tokens[0][0].value).toBe("^");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","support.other.match.begin.regexp"]);
      expect(tokens[0][1].value).toBe("a");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][2].value).toBe("{10}");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][3].value).toBe("b");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][4].value).toBe("{,10}");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][5].value).toBe("c");
      expect(tokens[0][5].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][6].value).toBe("{10,}");
      expect(tokens[0][6].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][7].value).toBe("d");
      expect(tokens[0][7].scopes).toEqual(["source.regexp.python"]);
      expect(tokens[0][8].value).toBe("{10,100}");
      expect(tokens[0][8].scopes).toEqual(["source.regexp.python","keyword.operator.quantifier.regexp"]);
      expect(tokens[0][9].value).toBe("$");
      expect(tokens[0][9].scopes).toEqual(["source.regexp.python","support.other.match.end.regexp"]);
    });

  it("test/regexp/set1.re", 
    function() {
      tokens = grammar.tokenizeLines("[]]")
      expect(tokens[0][0].value).toBe("[");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.begin.regexp"]);
      expect(tokens[0][1].value).toBe("]");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][2].value).toBe("]");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.end.regexp"]);
    });

  it("test/regexp/set2.re", 
    function() {
      tokens = grammar.tokenizeLines("[^]]")
      expect(tokens[0][0].value).toBe("[");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.begin.regexp"]);
      expect(tokens[0][1].value).toBe("^");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","keyword.operator.negation.regexp"]);
      expect(tokens[0][2].value).toBe("]");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][3].value).toBe("]");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.end.regexp"]);
    });

  it("test/regexp/set3.re", 
    function() {
      tokens = grammar.tokenizeLines("[][(){}|*+?.\\]\\\\]")
      expect(tokens[0][0].value).toBe("[");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.begin.regexp"]);
      expect(tokens[0][1].value).toBe("]");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][2].value).toBe("[");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][3].value).toBe("(");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][4].value).toBe(")");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][5].value).toBe("{");
      expect(tokens[0][5].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][6].value).toBe("}");
      expect(tokens[0][6].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][7].value).toBe("|");
      expect(tokens[0][7].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][8].value).toBe("*");
      expect(tokens[0][8].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][9].value).toBe("+");
      expect(tokens[0][9].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][10].value).toBe("?");
      expect(tokens[0][10].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][11].value).toBe(".");
      expect(tokens[0][11].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][12].value).toBe("\\]");
      expect(tokens[0][12].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][13].value).toBe("\\\\");
      expect(tokens[0][13].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.escape.regexp"]);
      expect(tokens[0][14].value).toBe("]");
      expect(tokens[0][14].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.end.regexp"]);
    });

  it("test/regexp/set4.re", 
    function() {
      tokens = grammar.tokenizeLines("^[^^]")
      expect(tokens[0][0].value).toBe("^");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python","support.other.match.begin.regexp"]);
      expect(tokens[0][1].value).toBe("[");
      expect(tokens[0][1].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.begin.regexp"]);
      expect(tokens[0][2].value).toBe("^");
      expect(tokens[0][2].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","keyword.operator.negation.regexp"]);
      expect(tokens[0][3].value).toBe("^");
      expect(tokens[0][3].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.character.set.regexp"]);
      expect(tokens[0][4].value).toBe("]");
      expect(tokens[0][4].scopes).toEqual(["source.regexp.python","meta.character.set.regexp","constant.other.set.regexp punctuation.character.set.end.regexp"]);
    });

  it("test/regexp/trivial.re", 
    function() {
      tokens = grammar.tokenizeLines("trivial")
      expect(tokens[0][0].value).toBe("trivial");
      expect(tokens[0][0].scopes).toEqual(["source.regexp.python"]);
    });
});

